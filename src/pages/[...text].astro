---
import '~/assets/text.css'
import PublicationInfo from '~/components/publication-info.astro'
import TextMetaContent from '~/components/text-meta-content.astro'
import { t } from '~/i18n'
import Layout from '~/layouts/Layout.astro'
import { generateTextJsonLd } from '~/utils/json-ld'
import { getPreferredLanguage } from '~/utils/language'
import { toSentenceCase, uidToAcronym } from '~/utils/strings'

const { text } = Astro.params
const acceptLanguage = Astro.request.headers.get('accept-language')
const userLanguage = getPreferredLanguage(acceptLanguage)

const parts = text!.split('/') // will be a string like "dn1/en/sujato"
if (parts.length !== 3) {
  Astro.response.status = 404
  Astro.response.statusText = 'Invalid text path format'
  return Astro.rewrite('/404')
}
const [acronym, language, authorUid] = parts

const suttasResponse = await fetch(
  `https://suttacentral.net/api/suttas/${acronym}/${authorUid}?lang=${language}&siteLanguage=${userLanguage}`
)
const suttasData = await suttasResponse.json()

const isRangeSutta = !!suttasData.range_uid

if (!suttasData.root_text && !suttasData.translation) {
  for (const author of suttasData.candidate_authors ?? []) {
    const response = await fetch(
      `https://suttacentral.net/api/suttas/${acronym}/${author}?lang=${language}&siteLanguage=${userLanguage}`
    )
    const data = await response.json()
    if (data.root_text || data.translation) {
      return Astro.redirect(`/${acronym}/${language}/${author}`)
    }
  }

  Astro.response.status = 404
  Astro.response.statusText = 'Text not found'
  return Astro.rewrite('/404')
}

const suttaplexResponse = await fetch(
  `https://suttacentral.net/api/suttaplex/${suttasData.range_uid ?? acronym}?language=${userLanguage}`
)
const suttaplexData = await suttaplexResponse.json()

if (!suttaplexData?.[0]?.uid) {
  Astro.response.status = 404
  Astro.response.statusText = 'Suttaplex UID not found'
  return Astro.rewrite('/404')
}

let bilaraData = {}
if (suttasData.segmented) {
  const bilaraResponse = await fetch(
    `https://suttacentral.net/api/bilarasuttas/${suttasData.range_uid ?? acronym}/${authorUid}?lang=${language}`
  )
  bilaraData = await bilaraResponse.json()

  if (bilaraData.msg === 'Not Found') {
    Astro.response.status = 404
    Astro.response.statusText = 'Bilara data not found'
    return Astro.rewrite('/404')
  }

  if (isRangeSutta) {
    const matchKey = (key: string) =>
      key.split(':')[0].toLowerCase() === acronym.toLowerCase() ||
      bilaraData.html_text[key]?.includes("class='range'") ||
      bilaraData.html_text[key]?.includes("class='range-title'") ||
      bilaraData.html_text[key]?.includes("class='subdivision'")
    bilaraData.keys_order = bilaraData.keys_order.filter(matchKey)
    for (const prop of [
      'html_text',
      'root_text',
      'translation_text',
      'comment_text',
      'variant_text',
    ]) {
      if (!bilaraData[prop]) continue
      bilaraData[prop] = Object.fromEntries(
        Object.entries(bilaraData[prop]).filter(([key]) => matchKey(key))
      )
    }
  }
}

const publicationResponse = await fetch(
  `https://suttacentral.net/api/publication_info/${suttasData.range_uid ?? acronym}/${language}/${authorUid}`
)
const publicationData = await publicationResponse.json()

const crumbsResponse = await fetch(
  `https://suttacentral.net/api/navigation_data/${suttasData.range_uid ?? acronym}?language=${userLanguage}`
)
const crumbsData = await crumbsResponse.json()
const modifiedCrumbsData = [
  ...crumbsData,
  {
    uid: acronym,
    title: isRangeSutta ? uidToAcronym(acronym) : suttaplexData[0].acronym,
    url: `/${acronym}`,
  },
  { uid: authorUid, title: suttasData.translation.author },
]

let rangePrev: string | null = null
let rangeNext: string | null = null
if (isRangeSutta) {
  const beginMatch = suttasData.vaggaBegin?.match(/^(.+?)(\d+)-(\d+)$/)
  const endMatch = suttasData.vaggaEnd?.match(/^(.+?)(\d+)-(\d+)$/)
  if (beginMatch && endMatch) {
    const prefix = beginMatch[1]
    const vaggaStart = parseInt(beginMatch[2], 10)
    const vaggaEnd = parseInt(endMatch[3], 10)
    const current = parseInt(acronym.replace(prefix, ''), 10)
    if (current > vaggaStart) rangePrev = `${prefix}${current - 1}`
    if (current < vaggaEnd) rangeNext = `${prefix}${current + 1}`
  }
}

const isSegmented = !!suttasData.segmented
const isRootText = language === suttaplexData[0].root_lang

let commentsHtml = ''

function getRootLangHTML() {
  if (!isSegmented || !isRootText) return null

  return bilaraData.keys_order
    .map(key => {
      const html = bilaraData.html_text[key]
      const text = bilaraData.root_text[key]
      const comment = bilaraData.variant_text?.[key]
      const ref = key.split(':').pop()

      if (!html) return ''

      const segment = `
    <span id="${key}" class="segment">
      <span class="reference" id="${ref}">
        <a href="#${ref}" title="${t(userLanguage, 'text:segmentNumber')}">${ref}</a>
      </span>
      ${
        text
          ? `
      <!-- This is not a translation, its the root text, the class is so it's not \`display: none\` by default. -->
      <span class="translation" lang="${suttasData.root_text.lang}" translate="no">
        <span class="text">${text}</span>
        ${
          comment
            ? `
        <button popovertarget="comment-${key}" aria-label="${t(userLanguage, 'viewoption:showVariantReading', { ref })}">*</button>
        <span class="inline-comment" aria-label="${t(userLanguage, 'viewoption:showVariantReading', { ref })}">
          ${t(userLanguage, 'viewoption:variant')} ${comment.replace(/https:\/\/suttacentral\.net/g, '')}
        </span>
        `
            : ''
        }
      </span>
      `
          : ''
      }
    </span>
  `

      if (comment) {
        commentsHtml += `
      <article id="comment-${key}" popover>
        ${t(userLanguage, 'viewoption:variant')} ${comment.replace(/https:\/\/suttacentral\.net/g, '')}
      </article>
    `
      }

      return html.replace('{}', segment)
    })
    .join('')
}

function getSegmentedHTML() {
  if (!isSegmented || isRootText) return null

  return bilaraData.keys_order
    .map(key => {
      const html = bilaraData.html_text[key]
      const text = bilaraData.translation_text[key]
      const rootText = bilaraData.root_text[key]
      const comment = bilaraData.comment_text?.[key]
      const ref = key.split(':').pop()

      if (!html) return ''

      const segment = `
    <span id="${key}" class="segment">
      <span class="reference" id="${ref}">
        <a href="#${ref}" title="${t(userLanguage, 'text:segmentNumber')}">${ref}</a>
      </span>
      ${
        text
          ? `
      <span class="translation" lang="${suttasData.translation.lang}">
        <span class="text">${text}</span>
        ${
          comment
            ? `
        <button popovertarget="comment-${key}" aria-label="${t(userLanguage, 'viewoption:showFootnote', { author: suttasData.translation.author, ref: key })}">*</button>
        <span class="inline-comment" aria-label="${t(userLanguage, 'viewoption:showFootnote', { author: suttasData.translation.author, ref: key })}">
          ${comment.replace(/https:\/\/suttacentral\.net/g, '')}
        </span>
        `
            : ''
        }
      </span>
      `
          : ''
      }
      ${
        rootText
          ? `
      <span class="root" lang="${suttasData.suttaplex.root_lang}" translate="no">
        <span class="text">${rootText}</span>
      </span>
      `
          : ''
      }
    </span>
  `

      if (comment) {
        commentsHtml += `
      <article id="comment-${key}" popover>
        ${comment.replace(/https:\/\/suttacentral\.net/g, '')}
      </article>
    `
      }

      return html.replace('{}', segment)
    })
    .join('')
}

function getLegacyHTML() {
  if (isSegmented) return null

  const htmlContent = suttasData?.translation.text.replace(/\n/g, '')
  // Extract the last <footer>...</footer> (its the publication info)
  const footerParts = htmlContent.split('<footer')
  const lastFooterPart = footerParts[footerParts.length - 1]
  const footerContent = lastFooterPart.split('</footer>')[0]
  const originalFooter = '<footer' + footerContent + '</footer>'
  // Remove footer from HTML
  const htmlWithoutFooter = htmlContent.replace(originalFooter, '')
  // Transform footer to info article with popover
  const modifiedFooter = originalFooter
    .replace('<footer', '<article id="info" popover')
    .replace('</footer>', '</article>')

  return htmlWithoutFooter + modifiedFooter
}

const rootLangHTML = getRootLangHTML()
const segmentedHTML = getSegmentedHTML()
const legacyHTML = getLegacyHTML()

const articleHTML = rootLangHTML || segmentedHTML || legacyHTML

const origin = Astro.site?.origin ?? ''
const jsonLd = generateTextJsonLd(
  suttasData,
  suttaplexData,
  modifiedCrumbsData,
  origin
)
---

<Layout
  title={isRangeSutta
    ? `${uidToAcronym(acronym)}—${suttasData.translation.author || suttasData.root_text.author}`
    : `${suttaplexData[0].acronym}: ${suttaplexData[0].original_title}—${suttasData.translation.author || suttasData.root_text.author}`}
  description={suttaplexData[0]?.blurb?.replace(/<[^>]*>/g, '')}
  breadcrumbs={modifiedCrumbsData}
  jsonLd={jsonLd}
  ogType="article"
  ogData={{
    'article:author': suttasData.translation?.author,
    'article:published_time': suttaplexData[0]?.translations?.find(
      t => t.author_uid === authorUid
    )?.publication_date,
    'article:section': 'Buddhist Texts',
    'article:tag': [
      'Early Buddhism',
      'Buddhism',
      'Buddhist Texts',
      'Pali Canon',
      'Tipitaka',
      'Theravada',
      'Suttas',
    ],
  }}
>
  <aside>
    <fieldset>
      <ul>
        <li>
          <button
            popovertarget="info"
            aria-label={t(userLanguage, 'viewoption:showPublicationInfo')}
          >
            {toSentenceCase(t(userLanguage, 'interface:infoButtonText'))}
          </button>
        </li>
        <li>
          <button
            aria-haspopup="menu"
            aria-expanded="false"
            aria-controls="views-menu"
            aria-label={t(userLanguage, 'interface:textSettings')}
            id="views-button"
          >
            {toSentenceCase(t(userLanguage, 'interface:toolsButtonText'))}
          </button>
          <ul
            class="dropdown"
            role="menu"
            aria-labelledby="views-button"
            id="views-menu"
          >
            {
              Object.keys(
                (isRootText
                  ? bilaraData.variant_text
                  : bilaraData.comment_text) || {}
              ).length > 0 && (
                <>
                  <li role="menuitem">
                    <label for="commenter">
                      {t(userLanguage, 'viewoption:showComments')}
                    </label>
                    <input
                      type="checkbox"
                      id="commenter"
                      checked
                      aria-controls="commenter-inline"
                    />
                  </li>
                  <li role="menuitem">
                    <label for="commenter-inline">
                      ↳ {t(userLanguage, 'viewoption:inline')}
                    </label>
                    <input
                      type="checkbox"
                      id="commenter-inline"
                      aria-controls="commenter-side"
                    />
                  </li>
                  <li role="menuitem">
                    <label for="commenter-side">
                      ↳ {t(userLanguage, 'viewoption:sideBySide')}
                    </label>
                    <input type="checkbox" id="commenter-side" />
                  </li>
                </>
              )
            }
            {
              isSegmented && !isRootText && (
                <>
                  <li role="menuitem">
                    <label for="rooter">
                      {t(userLanguage, 'viewoption:showRootText')}
                    </label>
                    <input
                      type="checkbox"
                      id="rooter"
                      aria-controls="rooter-first rooter-side"
                    />
                  </li>
                  <li role="menuitem">
                    <label for="rooter-first">
                      ↳ {t(userLanguage, 'viewoption:rootFirst')}
                    </label>
                    <input type="checkbox" id="rooter-first" />
                  </li>
                  <li role="menuitem">
                    <label for="rooter-side">
                      ↳ {t(userLanguage, 'viewoption:sideBySide')}
                    </label>
                    <input type="checkbox" id="rooter-side" />
                  </li>
                </>
              )
            }
            {
              (isSegmented ||
                suttasData.translation.text.includes("class='ref")) && (
                <li role="menuitem">
                  <label for="segmenter">
                    {t(userLanguage, 'viewoption:showSegments')}
                  </label>
                  <input type="checkbox" id="segmenter" />
                </li>
              )
            }
            <li role="menuitem">
              <label for="positioner"
                >{t(userLanguage, 'viewoption:pinMenu')}</label
              >
              <input type="checkbox" id="positioner" checked />
            </li>
          </ul>
        </li>
        <li>
          <button
            popovertarget="parallels"
            aria-label={t(userLanguage, 'viewoption:showParallelTexts')}
          >
            {
              toSentenceCase(
                t(userLanguage, 'interface:showParallelsButtonText')
              )
            }
          </button>
        </li>
        <li>
          <button
            aria-haspopup="menu"
            aria-expanded="false"
            aria-controls="listen-menu"
            aria-label={t(userLanguage, 'viewoption:ttsSettings')}
            id="listen-menu-button"
          >
            {t(userLanguage, 'viewoption:listen')}
          </button>
          <ul
            class="dropdown"
            role="menu"
            aria-labelledby="listen-menu-button"
            id="listen-menu"
            data-label-play={t(userLanguage, 'viewoption:play')}
            data-label-pause={t(userLanguage, 'viewoption:pause')}
            data-label-default={t(userLanguage, 'viewoption:voiceDefault')}
            data-text-lang={language}
          >
            <li>
              <noscript>
                {t(userLanguage, 'viewoption:ttsNoscript')}
              </noscript>
            </li>
            <li role="menuitem" class="tts-controls">
              <button id="prev" type="button">
                <span>⏮️</span><span>{t(userLanguage, 'viewoption:prev')}</span>
              </button>
              <button id="playpause" type="button">
                <span>▶️</span><span>{t(userLanguage, 'viewoption:play')}</span>
              </button>
              <button id="stop" type="button">
                <span>⏹️</span><span>{t(userLanguage, 'viewoption:stop')}</span>
              </button>
              <button id="next" type="button">
                <span>⏭️</span><span>{t(userLanguage, 'viewoption:next')}</span>
              </button>
            </li>
            <li role="menuitem">
              <label for="voice-select"
                >{t(userLanguage, 'viewoption:voiceLabel')}</label
              >
              <select id="voice-select"></select>
            </li>
            <li role="menuitem">
              <label for="rate">{t(userLanguage, 'viewoption:rate')}</label>
              <input
                type="range"
                min="0.5"
                max="2"
                value="1"
                step="0.1"
                id="rate"
              />
              <div id="rate-value">1.0</div>
            </li>
            <li role="menuitem">
              <label for="pitch">{t(userLanguage, 'viewoption:pitch')}</label>
              <input
                type="range"
                min="0"
                max="2"
                value="1"
                step="0.1"
                id="pitch"
              />
              <div id="pitch-value">1.0</div>
            </li>
            <li role="menuitem">
              <label for="auto-scroll"
                >{t(userLanguage, 'viewoption:autoScroll')}</label
              >
              <input type="checkbox" id="auto-scroll" />
            </li>
          </ul>
        </li>
      </ul>
    </fieldset>
  </aside>
  <main>
    <Fragment set:html={articleHTML} />
    <Fragment set:html={commentsHtml} />

    {
      !!publicationData && !publicationData.error && (
        <PublicationInfo entry={publicationData} />
      )
    }

    <article id="parallels" popover>
      <TextMetaContent
        data={suttaplexData[0]}
        userLanguage={userLanguage}
        parallelsOpen
        isIndividualRangeSutta={isRangeSutta}
        inRangeSuttaId={acronym}
      />
    </article>
  </main>
  <nav aria-label={t(userLanguage, 'interface:articlePagination')}>
    <div>
      {
        suttasData.translation?.previous?.uid ? (
          <>
            <span>{t(userLanguage, 'interface:previous')}</span>
            <a
              href={`/${suttasData.translation.previous.uid}/${suttasData.translation.previous.lang}/${suttasData.translation.previous.author_uid}`}
              rel="prev"
            >
              {suttasData.translation.previous?.name}
            </a>
          </>
        ) : (
          rangePrev && (
            <>
              <span>{t(userLanguage, 'interface:previous')}</span>
              <a href={`/${rangePrev}/${language}/${authorUid}`} rel="prev">
                {uidToAcronym(rangePrev)}
              </a>
            </>
          )
        )
      }
    </div>
    <div>
      {
        suttasData.translation?.next?.uid ? (
          <>
            <span>{t(userLanguage, 'interface:next')}</span>
            <a
              href={`/${suttasData.translation.next.uid}/${suttasData.translation.next.lang}/${suttasData.translation.next.author_uid}`}
              rel="next"
            >
              {suttasData.translation.next?.name}
            </a>
          </>
        ) : (
          rangeNext && (
            <>
              <span>{t(userLanguage, 'interface:next')}</span>
              <a href={`/${rangeNext}/${language}/${authorUid}`} rel="next">
                {uidToAcronym(rangeNext)}
              </a>
            </>
          )
        )
      }
    </div>
  </nav>
</Layout>

<script>
  /**
   * User Preferences Handler
   *
   * Persists UI control states (checkboxes, sliders, selects) for Speech Synthesis
   * and text view settings (comments, segments, root text) to localStorage.
   * Automatically saves on user interaction.
   *
   * @requires localStorage
   */
  'use strict'

  const IDS = [
    'commenter',
    'commenter-inline',
    'commenter-side',
    'rooter',
    'rooter-first',
    'rooter-side',
    'segmenter',
    'positioner',
    'voice-select',
    'rate',
    'pitch',
    'auto-scroll',
  ]

  const STORAGE_KEY = 'user-prefs'

  /**
   * Get stored preferences from localStorage
   * @returns {Object} Parsed preferences object or empty object if none exist
   */
  function getStoredPrefs() {
    try {
      return JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}')
    } catch (e) {
      console.error('Failed to parse stored prefs:', e)
      return {}
    }
  }

  /**
   * Wait for the voice-select element to be populated with options.
   * These can load asynchronously from SpeechSynthesis API,
   * so may not be immediately available.
   * Polls every 50ms until options are available or 5 seconds elapse.
   *
   * @returns {Promise<void>} Resolves when options are populated or element doesn't exist
   */
  function waitForVoiceSelect() {
    return new Promise(resolve => {
      const voiceSelect = document.getElementById('voice-select')
      if (!voiceSelect) {
        resolve()
        return
      }

      if (voiceSelect.options.length > 1) {
        resolve()
        return
      }

      let elapsed = 0
      const interval = setInterval(() => {
        elapsed += 50
        if (voiceSelect.options.length > 1) {
          clearInterval(interval)
          resolve()
        } else if (elapsed >= 5000) {
          clearInterval(interval)
          console.warn('Timeout waiting for voice-select options')
          resolve()
        }
      }, 50)
    })
  }

  /**
   * Load stored preferences (except voice-select) into existing elements.
   */
  function load() {
    const saved = getStoredPrefs()

    IDS.forEach(id => {
      const el = document.getElementById(id)
      if (!el || !(id in saved)) return

      if (el instanceof HTMLInputElement && el.type === 'checkbox') {
        el.checked = !!saved[id]
        return
      }

      // inputs with value
      if ('value' in el) {
        el.value = saved[id]
      }
    })
  }

  /**
   * Load voice-select preference once options are available
   */
  function loadVoiceSelect() {
    const el = document.getElementById('voice-select')
    if (!el) return

    const saved = getStoredPrefs()
    if (!('voice-select' in saved)) return

    const wanted = saved['voice-select']
    const opt = [...el.options].find(o => o.dataset.name === wanted)
    if (opt) el.value = opt.value
  }

  /**
   * Save current state of elements found on this page.
   */
  function save() {
    const prefs = getStoredPrefs()

    IDS.forEach(id => {
      const el = document.getElementById(id)
      if (!el) return

      if (el instanceof HTMLInputElement && el.type === 'checkbox') {
        prefs[id] = el.checked
        return
      }

      if (el instanceof HTMLSelectElement) {
        const opt = el.options[el.selectedIndex]
        prefs[id] = opt.dataset.name
        return
      }

      // inputs with value
      if ('value' in el) {
        prefs[id] = el.value
      }
    })

    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(prefs))
    } catch (e) {
      console.error('Failed to save preferences:', e)
    }
  }

  /**
   * Set up listeners for all elements present on the current page.
   */
  function init() {
    IDS.forEach(id => {
      const el = document.getElementById(id)
      if (!el) return
      el.addEventListener(el.type === 'range' ? 'input' : 'change', save)
    })
  }

  load()
  init()
  waitForVoiceSelect().then(loadVoiceSelect)
</script>

<script>
  /**
   * Text-to-Speech Player
   *
   * Provides speech synthesis controls for reading article content aloud.
   * Features include play/pause/stop controls, navigation between segments,
   * voice selection, pitch/rate adjustment, auto-scrolling, and click-to-jump.
   *
   * Handles both segmented text (via span.text elements) and non-segmented
   * content by manually extracting visible text-containing elements.
   *
   * @requires SpeechSynthesis API
   *
   * @example
   * // Access debug state
   * window._scx_listen.getState()
   *
   * @example
   * // Cancel all playback
   * window._scx_listen.cancel()
   */

  'use strict'

  // Configurable constants
  const TIMEOUT_MS = 60
  const CLASS_HIGHLIGHT = 'tts-highlight'
  const CLASS_CLICKABLE = 'tts-clickable'
  const ICON_PLAY = '▶️'
  const ICON_PAUSE = '⏸️'
  const ICON_RESUME = '▶️'

  const synth = window.speechSynthesis

  // state
  let voices = []
  let visibleTextSpans = []
  let visibleTextContent = []
  let currentIndex = 0
  let isCancelled = false
  let isPlaying = false // denotes an active session (playing or paused)
  let currentUtterance = null
  let sessionId = 0

  // DOM
  const menuButton = document.getElementById('listen-menu-button')
  const rootMenuEl = document.getElementById('listen-menu')
  const LABEL_PLAY = rootMenuEl.dataset.labelPlay
  const LABEL_PAUSE = rootMenuEl.dataset.labelPause
  const LABEL_RESUME = LABEL_PLAY
  const LABEL_DEFAULT = rootMenuEl.dataset.labelDefault
  const voiceSelect = document.getElementById('voice-select')
  const pitch = document.getElementById('pitch')
  const pitchValue = document.getElementById('pitch-value')
  const rate = document.getElementById('rate')
  const rateValue = document.getElementById('rate-value')

  const prevBtn = document.getElementById('prev')
  const playPauseBtn = document.getElementById('playpause')
  const playPauseBtnIcon = playPauseBtn.getElementsByTagName('span')[0]
  const playPauseBtnLabel = playPauseBtn.getElementsByTagName('span')[1]
  const nextBtn = document.getElementById('next')
  const stopBtn = document.getElementById('stop')
  const autoScrollToggle = document.getElementById('auto-scroll')

  const rootFirst = document.getElementById('rooter-first')

  // basic sanity
  if (!rootMenuEl) {
    console.warn('listen.js: required controls missing; aborting init.')
  } else {
    // enable all the controls (they are disabled by default to show fallback text if user has JS turned off)
    rootMenuEl.style.maxWidth = '100vw'
    rootMenuEl.querySelectorAll('li[role="menuitem"]').forEach(el => {
      el.style.display = 'flex'
    })

    function computeVisibleText() {
      // for segmented texts
      visibleTextSpans = Array.from(
        document.querySelectorAll(
          'main > article span.text, main > section span.text'
        )
      ).filter(s => s.offsetParent !== null && s.textContent)

      visibleTextContent = visibleTextSpans?.map(s =>
        s.textContent.replace(/\n/g, '')
      )

      // If rooter-first is checked, reorder spans within each segment to match CSS grid display order
      if (rootFirst && rootFirst.checked && visibleTextSpans.length > 0) {
        const segments = new Map()

        // Group spans by their parent segment
        visibleTextSpans.forEach((span, index) => {
          const segment = span.closest('.segment')
          if (segment) {
            if (!segments.has(segment)) {
              segments.set(segment, [])
            }
            segments.get(segment).push({ span, index })
          }
        })

        // For each segment, if it has both translation and root text, swap their order
        segments.forEach((items, segment) => {
          if (items.length >= 2) {
            const translationItem = items.find(item =>
              item.span.closest('.translation')
            )
            const rootItem = items.find(item => item.span.closest('.root'))

            // If both exist, swap them in the arrays
            if (translationItem && rootItem) {
              const tempSpan = visibleTextSpans[translationItem.index]
              const tempContent = visibleTextContent[translationItem.index]

              visibleTextSpans[translationItem.index] =
                visibleTextSpans[rootItem.index]
              visibleTextContent[translationItem.index] =
                visibleTextContent[rootItem.index]

              visibleTextSpans[rootItem.index] = tempSpan
              visibleTextContent[rootItem.index] = tempContent
            }
          }
        })
      }

      // fallback for messy DOM in non segmented texts
      if (!visibleTextSpans.length || !visibleTextContent.length) {
        const textContainingElements = [
          'div',
          'span',
          'p',
          'blockquote',
          'pre',
          'address',
          'h1',
          'h2',
          'h3',
          'h4',
          'h5',
          'h6',
          'ul',
          'ol',
          'li',
          'dl',
          'dt',
          'dd',
          'a',
          'abbr',
          'b',
          'strong',
          'i',
          'em',
          'mark',
          'small',
          'del',
          'ins',
          'sub',
          'sup',
          'code',
          'kbd',
          'samp',
          'var',
          'cite',
          'dfn',
          'q',
          's',
          'u',
          'time',
          'data',
          'bdi',
          'bdo',
          'ruby',
          'rt',
          'rp',
          'table',
          'caption',
          'thead',
          'tbody',
          'tfoot',
          'tr',
          'th',
          'td',
          'colgroup',
          'col',
          'form',
          'label',
          'button',
        ]
        const selector = textContainingElements
          .map(e => `main > article ${e}`)
          .join(', ')
        const allVisibleElements = Array.from(
          document.querySelectorAll(selector)
        ).filter(s => s.offsetParent !== null && s.textContent)

        function getUniqueSelector(node, root) {
          const path = []
          let current = node
          while (current && current !== root) {
            let index = 0
            let sibling = current
            while ((sibling = sibling.previousElementSibling)) {
              if (sibling.tagName === current.tagName) index++
            }
            path.unshift(
              `${current.tagName.toLowerCase()}:nth-of-type(${index + 1})`
            )
            current = current.parentElement
          }
          return path.join(' > ')
        }

        visibleTextSpans = allVisibleElements.filter(el => {
          // avoid duplicates
          return !allVisibleElements.some(
            other => other !== el && other.contains(el)
          )
        })

        visibleTextContent = visibleTextSpans.map(el => {
          const clone = el.cloneNode(true)

          // remove all .ref elements from the clone
          const refElements = clone.querySelectorAll('.ref')
          refElements.forEach(ref => ref.remove())

          // Find all descendants in the clone and check if corresponding original is hidden
          const allDescendants = clone.querySelectorAll('*')
          Array.from(allDescendants).forEach(cloneDesc => {
            const selector = getUniqueSelector(cloneDesc, clone)
            const originalDesc = el.querySelector(selector)
            if (originalDesc && originalDesc.offsetParent === null) {
              cloneDesc.remove()
            }
          })

          return clone.textContent.replace(/\n/g, '')
        })
      }
    }

    function updateClickableSpans() {
      if (!visibleTextSpans || !visibleTextSpans.length) return
      if (isPlaying) {
        visibleTextSpans.forEach(s => s.classList.add(CLASS_CLICKABLE))
      } else {
        visibleTextSpans.forEach(s => s.classList.remove(CLASS_CLICKABLE))
      }
    }

    function setNavControlsEnabled(enabled) {
      if (prevBtn) prevBtn.disabled = !enabled
      if (nextBtn) nextBtn.disabled = !enabled
      if (stopBtn) stopBtn.disabled = !enabled
    }

    function ensureVisible(index) {
      if (!autoScrollToggle) return
      if (!autoScrollToggle.checked) return
      const el = visibleTextSpans[index]
      if (!el) return
      try {
        el.scrollIntoView({
          behavior: 'smooth',
          block: 'center',
          inline: 'nearest',
        })
      } catch (e) {}
    }

    function updatePlayPauseLabel() {
      if (synth.paused) {
        playPauseBtnLabel.textContent = LABEL_RESUME
        playPauseBtnIcon.textContent = ICON_RESUME
        return
      }
      if (synth.speaking && !synth.paused) {
        playPauseBtnLabel.textContent = LABEL_PAUSE
        playPauseBtnIcon.textContent = ICON_PAUSE
        return
      }
      playPauseBtnLabel.textContent = LABEL_PLAY
      playPauseBtnIcon.textContent = ICON_PLAY
    }

    function populateVoiceList() {
      voices =
        typeof synth.getVoices === 'function' ? synth.getVoices().slice() : []

      // Group voices by language
      const byLang = new Map()
      for (const v of voices) {
        const lang = v.lang || 'unknown'
        if (!byLang.has(lang)) byLang.set(lang, [])
        byLang.get(lang).push(v)
      }

      // Sort languages alphabetically
      const langs = Array.from(byLang.keys()).sort((a, b) => {
        const aa = (a || '').toUpperCase()
        const bb = (b || '').toUpperCase()
        if (aa < bb) return -1
        if (aa === bb) return 0
        return 1
      })

      // Sort voices within each language by name
      for (const [, list] of byLang) {
        list.sort((a, b) => {
          const an = (a.name || '').toUpperCase()
          const bn = (b.name || '').toUpperCase()
          if (an < bn) return -1
          if (an === bn) return 0
          return 1
        })
      }

      // Determine preferred voice to select: text language first, then default voice, then browser lang
      const defaultVoice = voices.find(v => v.default)
      const textLang = rootMenuEl?.dataset?.textLang ?? ''
      const browserLang = (
        navigator.language ||
        navigator.userLanguage ||
        ''
      ).toString()
      const primaryBrowserLang = browserLang.split('-')[0]
      let suitableVoiceName = null

      // First try to match text language (prefer default voice if multiple matches)
      if (textLang) {
        const textLangVoices = voices.filter(
          v => v.lang === textLang || (v.lang && v.lang.startsWith(textLang))
        )
        if (textLangVoices.length > 0) {
          const defaultInLang = textLangVoices.find(v => v.default)
          suitableVoiceName = defaultInLang
            ? defaultInLang.name
            : textLangVoices[0].name
        }
      }

      // Fall back to default voice
      if (!suitableVoiceName && defaultVoice) {
        suitableVoiceName = defaultVoice.name
      }

      // Fall back to browser language
      if (!suitableVoiceName && browserLang) {
        // find first voice matching full lang, then primary subtag
        let found = voices.find(v => v.lang === browserLang)
        if (!found)
          found = voices.find(
            v => v.lang && v.lang.startsWith(primaryBrowserLang)
          )
        if (found) suitableVoiceName = found.name
      }

      // Build select with optgroups per language
      voiceSelect.innerHTML = ''
      for (const lang of langs) {
        const group = document.createElement('optgroup')
        group.label = lang
        const list = byLang.get(lang) || []
        for (const v of list) {
          const opt = document.createElement('option')
          opt.textContent = `${v.name}${v.default ? ` -- ${LABEL_DEFAULT}` : ''}`
          opt.setAttribute('data-name', v.name)
          opt.setAttribute('data-lang', v.lang)
          group.appendChild(opt)
        }
        voiceSelect.appendChild(group)
      }

      // Select initial option if present, otherwise preserve previous selection or pick first
      let selIndex = 0
      if (suitableVoiceName) {
        for (let i = 0; i < voiceSelect.options.length; i++) {
          if (
            voiceSelect.options[i].getAttribute('data-name') ===
            suitableVoiceName
          ) {
            selIndex = i
            break
          }
        }
      } else {
        selIndex =
          voiceSelect.selectedIndex >= 0 ? voiceSelect.selectedIndex : 0
      }
      voiceSelect.selectedIndex = Math.min(
        selIndex,
        Math.max(0, voiceSelect.options.length - 1)
      )
    }
    populateVoiceList()
    if (typeof synth !== 'undefined' && synth.onvoiceschanged !== undefined) {
      synth.onvoiceschanged = populateVoiceList
    }

    // Speak chain with session protection
    function speakNext() {
      const mySession = sessionId
      if (currentIndex >= visibleTextContent.length) {
        finishPlayback()
        return
      }
      const text = visibleTextContent[currentIndex]
      if (!text || isCancelled) {
        finishPlayback()
        return
      }

      const utter = new SpeechSynthesisUtterance(text)
      utter._session = mySession
      currentUtterance = utter

      utter.onstart = () => {
        if (utter._session !== sessionId) return
        visibleTextSpans[currentIndex]?.classList.add(CLASS_HIGHLIGHT)
        ensureVisible(currentIndex)
        // immediate label update when speech starts
        updatePlayPauseLabel()
      }

      utter.onend = () => {
        if (utter._session !== sessionId) return
        visibleTextSpans[currentIndex]?.classList.remove(CLASS_HIGHLIGHT)
        currentUtterance = null
        if (isCancelled) {
          finishPlayback()
          return
        }
        currentIndex += 1
        // If paused between utterances, don't auto-advance
        if (synth.paused) {
          updatePlayPauseLabel()
          return
        }
        speakNext()
      }

      utter.onerror = ev => {
        if (utter._session !== sessionId) return
        console.error('SpeechSynthesisUtterance error', ev)
        visibleTextSpans[currentIndex]?.classList.remove(CLASS_HIGHLIGHT)
        currentUtterance = null
        currentIndex += 1
        if (!isCancelled) speakNext()
      }

      // set voice
      const selected =
        voiceSelect.selectedOptions && voiceSelect.selectedOptions[0]
          ? voiceSelect.selectedOptions[0].getAttribute('data-name')
          : null
      if (selected) {
        const v = voices.find(x => x.name === selected)
        if (v) utter.voice = v
      }
      utter.pitch = pitch ? Number(pitch.value) : 1
      utter.rate = rate ? Number(rate.value) : 1

      try {
        synth.speak(utter)
      } catch (err) {
        console.error('synth.speak threw', err)
      }
    }

    // Controls
    function startSessionFrom(index = 0) {
      computeVisibleText()
      if (!visibleTextContent.length || !visibleTextSpans.length) return
      sessionId += 1
      isCancelled = false
      isPlaying = true
      currentIndex = Math.max(0, Math.min(index, visibleTextContent.length - 1))
      playPauseBtnLabel.textContent = LABEL_PAUSE
      playPauseBtnIcon.textContent = ICON_PAUSE
      setNavControlsEnabled(true)
      updateClickableSpans()
      speakNext()
    }

    function pauseSession() {
      if (synth.speaking && !synth.paused) {
        try {
          synth.pause()
          // set label immediately for UI responsiveness
          playPauseBtnLabel.textContent = LABEL_RESUME
          playPauseBtnIcon.textContent = ICON_RESUME
          return
        } catch (err) {
          console.error('pause failed', err)
        }
      }
      updateClickableSpans()
    }

    function resumeSession() {
      if (synth.paused) {
        try {
          synth.resume()
          // set label immediately for UI responsiveness
          playPauseBtnLabel.textContent = LABEL_PAUSE
          playPauseBtnIcon.textContent = ICON_PAUSE
        } catch (err) {
          console.error('resume failed', err)
        }
      } else if (
        !synth.speaking &&
        !isCancelled &&
        currentIndex < visibleTextContent.length
      ) {
        // nothing is speaking but we have work to do
        speakNext()
        playPauseBtnLabel.textContent = LABEL_PAUSE
        playPauseBtnIcon.textContent = ICON_PAUSE
      }
      updateClickableSpans()
    }

    function prevSpan() {
      computeVisibleText()
      if (!visibleTextContent.length) return
      const newIndex = Math.max(0, currentIndex - 1)
      sessionId += 1
      isCancelled = true
      try {
        synth.cancel()
      } catch (e) {}
      visibleTextSpans.forEach(s => s.classList.remove(CLASS_HIGHLIGHT))
      setTimeout(() => {
        if (sessionId == null) return
        isCancelled = false
        currentIndex = newIndex
        if (isPlaying && !synth.paused) {
          speakNext()
        } else {
          visibleTextSpans[currentIndex]?.classList.add(CLASS_HIGHLIGHT)
          ensureVisible(currentIndex)
          updatePlayPauseLabel()
        }
      }, TIMEOUT_MS)
    }

    function nextSpan() {
      computeVisibleText()
      if (!visibleTextContent.length) return
      const newIndex = Math.min(visibleTextContent.length - 1, currentIndex + 1)
      sessionId += 1
      isCancelled = true
      try {
        synth.cancel()
      } catch (e) {}
      visibleTextSpans.forEach(s => s.classList.remove(CLASS_HIGHLIGHT))
      setTimeout(() => {
        if (sessionId == null) return
        isCancelled = false
        currentIndex = newIndex
        if (isPlaying && !synth.paused) {
          speakNext()
        } else {
          visibleTextSpans[currentIndex]?.classList.add(CLASS_HIGHLIGHT)
          ensureVisible(currentIndex)
          updatePlayPauseLabel()
        }
      }, TIMEOUT_MS)
    }

    function finishPlayback() {
      sessionId += 1
      visibleTextSpans.forEach(s => {
        s.classList.remove(CLASS_HIGHLIGHT)
        s.classList.remove(CLASS_CLICKABLE)
      })
      isPlaying = false
      currentUtterance = null
      currentIndex = 0
      playPauseBtnLabel.textContent = LABEL_PLAY
      playPauseBtnIcon.textContent = ICON_PLAY
      setNavControlsEnabled(false)
      updateClickableSpans()
    }

    function stopSession() {
      // Cancel any ongoing speech and reset UI/state.
      sessionId += 1
      isCancelled = true
      try {
        synth.cancel()
      } catch (e) {}
      visibleTextSpans.forEach(s => {
        s.classList.remove(CLASS_HIGHLIGHT)
      })
      currentUtterance = null
      isPlaying = false
      currentIndex = 0
      playPauseBtnLabel.textContent = LABEL_PLAY
      playPauseBtnIcon.textContent = ICON_PLAY
      setNavControlsEnabled(false)
      updateClickableSpans()
    }

    // single button behavior
    function togglePlayPause() {
      if (synth.paused) {
        // if paused, resume immediately and update label
        resumeSession()
        return
      }
      if (isPlaying && synth.speaking && !synth.paused) {
        // pause immediately and update label
        pauseSession()
        return
      }
      // not started -> start session from currentIndex (or 0)
      if (!isPlaying) {
        startSessionFrom(currentIndex || 0)
        return
      }
      // if idle but there's remaining content, continue
      if (
        !synth.speaking &&
        !isCancelled &&
        currentIndex < visibleTextContent.length
      ) {
        isPlaying = true
        playPauseBtnLabel.textContent = LABEL_PAUSE
        playPauseBtnIcon.textContent = ICON_PAUSE
        updateClickableSpans()
        speakNext()
      }
    }

    // wire listeners
    if (prevBtn) prevBtn.addEventListener('click', prevSpan)
    playPauseBtn.addEventListener('click', togglePlayPause)
    if (nextBtn) nextBtn.addEventListener('click', nextSpan)
    if (stopBtn) stopBtn.addEventListener('click', stopSession)

    // allow clicking any visibleTextSpans to jump/start speaking from there
    const articleEl = document.querySelector('main > article, main > section')
    if (articleEl)
      articleEl.addEventListener('click', ev => {
        // Only allow click-to-jump once playback has already started
        if (!isPlaying) return

        // find the nearest element that was clicked
        // for segmented texts this will work
        let clickedElement =
          ev.target && ev.target.closest ? ev.target.closest('span.text') : null

        // for non-segmented texts, check if it's one of the visibleTextSpans
        if (!clickedElement) {
          // ignore reference link clicks
          if (ev.target.closest('.ref')) return

          clickedElement = ev.target
          // Walk up the tree to find if we're inside a visibleTextSpan
          while (clickedElement && !visibleTextSpans.includes(clickedElement)) {
            clickedElement = clickedElement.parentElement
            if (clickedElement === articleEl) {
              clickedElement = null
              break
            }
          }
        }

        if (!clickedElement) return

        computeVisibleText()
        const idx = visibleTextSpans.indexOf(clickedElement)
        if (idx < 0) return

        // cancel current session/utterances and start from clicked index
        sessionId += 1
        isCancelled = true
        try {
          synth.cancel()
        } catch (e) {}
        visibleTextSpans.forEach(s => s.classList.remove(CLASS_HIGHLIGHT))

        setTimeout(() => {
          isCancelled = false
          // reuse existing start logic to initialize state and begin speaking
          startSessionFrom(idx)
        }, TIMEOUT_MS)
      })

    if (pitch) {
      pitchValue.textContent = pitch.valueAsNumber.toFixed(1)
      pitch.addEventListener(
        'change',
        () => (pitchValue.textContent = pitch.valueAsNumber.toFixed(1))
      )
    }
    if (rate) {
      rateValue.textContent = rate.valueAsNumber.toFixed(1)
      rate.addEventListener(
        'change',
        () => (rateValue.textContent = rate.valueAsNumber.toFixed(1))
      )
    }

    // initial nav state
    setNavControlsEnabled(false)

    // debug helper
    window._scx_listen = {
      getState() {
        return {
          isPlaying,
          isCancelled,
          currentIndex,
          sessionId,
          paused: synth.paused,
          speaking: synth.speaking,
        }
      },
      cancel() {
        sessionId += 1
        isCancelled = true
        try {
          synth.cancel()
        } catch (e) {}
      },
    }
  }
</script>
