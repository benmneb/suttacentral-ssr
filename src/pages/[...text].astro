---
import '~/assets/text.css'
import PublicationInfo from '~/components/publication-info.astro'
import TextMetaContent from '~/components/text-meta-content.astro'
import { AVAILABLE_LOOKUPS } from '~/constants/lookup'
import { t } from '~/i18n'
import Layout from '~/layouts/Layout.astro'
import { getViewPrefs } from '~/utils/cookies'
import { generateTextJsonLd } from '~/utils/json-ld'
import { getPreferredLanguage } from '~/utils/language'
import { toSentenceCase, uidToAcronym } from '~/utils/strings'

const { text } = Astro.params
const viewPrefs = getViewPrefs(Astro.cookies)
const acceptLanguage = Astro.request.headers.get('accept-language')
const userLanguage = getPreferredLanguage(acceptLanguage)

const parts = text!.split('/') // will be a string like "dn1/en/sujato"
if (parts.length !== 3) {
  Astro.response.status = 404
  Astro.response.statusText = 'Invalid text path format'
  return Astro.rewrite('/404')
}
const [acronym, language, authorUid] = parts

const suttasResponse = await fetch(
  `https://suttacentral.net/api/suttas/${acronym}/${authorUid}?lang=${language}&siteLanguage=${userLanguage}`
)
const suttasData = await suttasResponse.json()

const isRangeSutta = !!suttasData.range_uid

if (!suttasData.root_text && !suttasData.translation) {
  for (const author of suttasData.candidate_authors ?? []) {
    const response = await fetch(
      `https://suttacentral.net/api/suttas/${acronym}/${author}?lang=${language}&siteLanguage=${userLanguage}`
    )
    const data = await response.json()
    if (data.root_text || data.translation) {
      return Astro.redirect(`/${acronym}/${language}/${author}`)
    }
  }

  Astro.response.status = 404
  Astro.response.statusText = 'Text not found'
  return Astro.rewrite('/404')
}

const suttaplexResponse = await fetch(
  `https://suttacentral.net/api/suttaplex/${suttasData.range_uid ?? acronym}?language=${userLanguage}`
)
const suttaplexData = await suttaplexResponse.json()

if (!suttaplexData?.[0]?.uid) {
  Astro.response.status = 404
  Astro.response.statusText = 'Suttaplex UID not found'
  return Astro.rewrite('/404')
}

let bilaraData = {}
if (suttasData.segmented) {
  const bilaraResponse = await fetch(
    `https://suttacentral.net/api/bilarasuttas/${suttasData.range_uid ?? acronym}/${authorUid}?lang=${language}`
  )
  bilaraData = await bilaraResponse.json()

  if (bilaraData.msg === 'Not Found') {
    Astro.response.status = 404
    Astro.response.statusText = 'Bilara data not found'
    return Astro.rewrite('/404')
  }

  if (isRangeSutta) {
    const matchKey = (key: string) =>
      key.split(':')[0].toLowerCase() === acronym.toLowerCase() ||
      bilaraData.html_text[key]?.includes("class='range'") ||
      bilaraData.html_text[key]?.includes("class='range-title'") ||
      bilaraData.html_text[key]?.includes("class='subdivision'")
    bilaraData.keys_order = bilaraData.keys_order.filter(matchKey)
    for (const prop of [
      'html_text',
      'root_text',
      'translation_text',
      'comment_text',
      'variant_text',
    ]) {
      if (!bilaraData[prop]) continue
      bilaraData[prop] = Object.fromEntries(
        Object.entries(bilaraData[prop]).filter(([key]) => matchKey(key))
      )
    }
  }
}

const [publicationData, crumbsData] = await Promise.all([
  fetch(
    `https://suttacentral.net/api/publication_info/${suttasData.range_uid ?? acronym}/${language}/${authorUid}`
  ).then(r => r.json()),
  fetch(
    `https://suttacentral.net/api/navigation_data/${suttasData.range_uid ?? acronym}?language=${userLanguage}`
  ).then(r => r.json()),
])
const modifiedCrumbsData = [
  ...crumbsData,
  {
    uid: acronym,
    title: isRangeSutta ? uidToAcronym(acronym) : suttaplexData[0].acronym,
    url: `/${acronym}`,
  },
  { uid: authorUid, title: suttasData.translation.author },
]

let rangePrev: string | null = null
let rangeNext: string | null = null
if (isRangeSutta) {
  const beginMatch = suttasData.vaggaBegin?.match(/^(.+?)(\d+)-(\d+)$/)
  const endMatch = suttasData.vaggaEnd?.match(/^(.+?)(\d+)-(\d+)$/)
  if (beginMatch && endMatch) {
    const prefix = beginMatch[1]
    const vaggaStart = parseInt(beginMatch[2], 10)
    const vaggaEnd = parseInt(endMatch[3], 10)
    const current = parseInt(acronym.replace(prefix, ''), 10)
    if (current > vaggaStart) rangePrev = `${prefix}${current - 1}`
    if (current < vaggaEnd) rangeNext = `${prefix}${current + 1}`
  }
}

const isSegmented = !!suttasData.segmented
const isRootText = language === suttaplexData[0].root_lang

const rootLang = suttasData.suttaplex?.root_lang
const availableLangs = rootLang ? AVAILABLE_LOOKUPS[rootLang] : null
const lookupTargetLang = availableLangs?.includes(userLanguage)
  ? userLanguage
  : 'en'

function cleanWord(text: string): string {
  // strip non-letter characters and lowercase
  return text.toLowerCase().replace(/^[^\p{L}]+|[^\p{L}]+$/gu, '')
}

function renderLookupWord(text: string): string {
  const cleaned = cleanWord(text)
  if (!cleaned) return text // punctuation etc
  return `<a class="look-up" href="/define/${cleaned}">${text}</a>`
}

function renderLookupChinese(text: string): string {
  if (!availableLangs) return text
  return [...text]
    .map(ch =>
      /\p{Script=Han}/u.test(ch)
        ? `<a class="look-up" href="/define/${encodeURIComponent(ch)}">${ch}</a>`
        : ch
    )
    .join('')
}

let commentsHtml = ''

function getRootLangHTML() {
  if (!isSegmented || !isRootText) return null

  return bilaraData.keys_order
    .map(key => {
      const html = bilaraData.html_text[key]
      const text = bilaraData.root_text[key]
      const comment = bilaraData.variant_text?.[key]
      const ref = key.split(':').pop()

      if (!html) return ''

      const segment = `
    <span id="${key}" class="segment">
      <span class="reference" id="${ref}">
        <a href="#${ref}" title="${t(userLanguage, 'text:segmentNumber')}">${ref}</a>
      </span>
      ${
        text
          ? `
      <!-- This is not a translation, its the root text, the class is so it's not \`display: none\` by default. -->
      <span class="translation" lang="${suttasData.root_text.lang}" translate="no">
        <span class="text">${availableLangs ? (rootLang === 'lzh' ? renderLookupChinese(text) : text.split(' ').map(renderLookupWord).join(' ')) : text}</span>
        ${
          comment
            ? `
        <button popovertarget="comment-${key}" aria-label="${t(userLanguage, 'viewoption:showVariantReading', { ref })}">*</button>
        <span class="inline-comment" aria-label="${t(userLanguage, 'viewoption:showVariantReading', { ref })}">
          ${t(userLanguage, 'viewoption:variant')} ${comment.replace(/https:\/\/suttacentral\.net/g, '')}
        </span>
        `
            : ''
        }
      </span>
      `
          : ''
      }
    </span>
  `

      if (comment) {
        commentsHtml += `
      <article id="comment-${key}" popover>
        ${t(userLanguage, 'viewoption:variant')} ${comment.replace(/https:\/\/suttacentral\.net/g, '')}
      </article>
    `
      }

      return html.replace('{}', segment)
    })
    .join('')
}

function getSegmentedHTML() {
  if (!isSegmented || isRootText) return null

  return bilaraData.keys_order
    .map(key => {
      const html = bilaraData.html_text[key]
      const text = bilaraData.translation_text[key]
      const rootText = bilaraData.root_text[key]
      const comment = bilaraData.comment_text?.[key]
      const ref = key.split(':').pop()

      if (!html) return ''

      const segment = `
    <span id="${key}" class="segment">
      <span class="reference" id="${ref}">
        <a href="#${ref}" title="${t(userLanguage, 'text:segmentNumber')}">${ref}</a>
      </span>
      ${
        text
          ? `
      <span class="translation" lang="${suttasData.translation.lang}">
        <span class="text">${text}</span>
        ${
          comment
            ? `
        <button popovertarget="comment-${key}" aria-label="${t(userLanguage, 'viewoption:showFootnote', { author: suttasData.translation.author, ref: key })}">*</button>
        <span class="inline-comment" aria-label="${t(userLanguage, 'viewoption:showFootnote', { author: suttasData.translation.author, ref: key })}">
          ${comment.replace(/https:\/\/suttacentral\.net/g, '')}
        </span>
        `
            : ''
        }
      </span>
      `
          : ''
      }
      ${
        rootText
          ? `
      <span class="root" lang="${suttasData.suttaplex.root_lang}" translate="no">
        <span class="text">
          ${rootLang === 'lzh' ? renderLookupChinese(rootText) : rootText.split(' ').map(renderLookupWord).join(' ')}
        </span>
      </span>
      `
          : ''
      }
    </span>
  `

      if (comment) {
        commentsHtml += `
      <article id="comment-${key}" popover>
        ${comment.replace(/https:\/\/suttacentral\.net/g, '')}
      </article>
    `
      }

      return html.replace('{}', segment)
    })
    .join('')
}

function getLegacyHTML() {
  if (isSegmented) return null

  const htmlContent = suttasData?.translation.text.replace(/\n/g, '')
  // Extract the last <footer>...</footer> (its the publication info)
  const footerParts = htmlContent.split('<footer')
  const lastFooterPart = footerParts[footerParts.length - 1]
  const footerContent = lastFooterPart.split('</footer>')[0]
  const originalFooter = '<footer' + footerContent + '</footer>'
  // Remove footer from HTML
  const htmlWithoutFooter = htmlContent.replace(originalFooter, '')
  // Transform footer to info article with popover
  const modifiedFooter = originalFooter
    .replace('<footer', '<article id="info" popover')
    .replace('</footer>', '</article>')

  return htmlWithoutFooter + modifiedFooter
}

const rootLangHTML = getRootLangHTML()
const segmentedHTML = getSegmentedHTML()
const legacyHTML = getLegacyHTML()

const articleHTML = rootLangHTML || segmentedHTML || legacyHTML

const origin = Astro.site?.origin ?? ''
const jsonLd = generateTextJsonLd(
  suttasData,
  suttaplexData,
  modifiedCrumbsData,
  origin
)
---

<Layout
  title={isRangeSutta
    ? `${uidToAcronym(acronym)}‚Äî${suttasData.translation.author || suttasData.root_text.author}`
    : `${suttaplexData[0].acronym}: ${suttaplexData[0].original_title}‚Äî${suttasData.translation.author || suttasData.root_text.author}`}
  description={suttaplexData[0]?.blurb?.replace(/<[^>]*>/g, '')}
  breadcrumbs={modifiedCrumbsData}
  jsonLd={jsonLd}
  ogType="article"
  ogData={{
    'article:author': suttasData.translation?.author,
    'article:published_time': suttaplexData[0]?.translations?.find(
      t => t.author_uid === authorUid
    )?.publication_date,
    'article:section': 'Buddhist Texts',
    'article:tag': [
      'Early Buddhism',
      'Buddhism',
      'Buddhist Texts',
      'Pali Canon',
      'Tipitaka',
      'Theravada',
      'Suttas',
    ],
  }}
>
  <aside>
    <fieldset>
      <ul>
        <li>
          <button
            popovertarget="info"
            aria-label={t(userLanguage, 'viewoption:showPublicationInfo')}
          >
            {toSentenceCase(t(userLanguage, 'interface:infoButtonText'))}
          </button>
        </li>
        <li>
          <button
            aria-haspopup="menu"
            aria-expanded="false"
            aria-controls="views-menu"
            aria-label={t(userLanguage, 'interface:textSettings')}
            id="views-button"
          >
            {toSentenceCase(t(userLanguage, 'interface:toolsButtonText'))}
          </button>
          <ul
            class="dropdown"
            role="menu"
            aria-labelledby="views-button"
            id="views-menu"
          >
            {
              Object.keys(
                (isRootText
                  ? bilaraData.variant_text
                  : bilaraData.comment_text) || {}
              ).length > 0 && (
                <>
                  <li role="menuitem">
                    <label for="commenter">
                      {t(userLanguage, 'viewoption:showComments')}
                    </label>
                    <input
                      type="checkbox"
                      id="commenter"
                      checked={viewPrefs.commenter ?? true}
                      aria-controls="commenter-inline"
                    />
                  </li>
                  <li role="menuitem">
                    <label for="commenter-inline">
                      ‚Ü≥ {t(userLanguage, 'viewoption:inline')}
                    </label>
                    <input
                      type="checkbox"
                      id="commenter-inline"
                      checked={viewPrefs['commenter-inline'] ?? false}
                      aria-controls="commenter-side"
                    />
                  </li>
                  <li role="menuitem">
                    <label for="commenter-side">
                      ‚Ü≥ {t(userLanguage, 'viewoption:sideBySide')}
                    </label>
                    <input
                      type="checkbox"
                      id="commenter-side"
                      checked={viewPrefs['commenter-side'] ?? false}
                    />
                  </li>
                </>
              )
            }
            {
              isSegmented && !isRootText && (
                <>
                  <li role="menuitem">
                    <label for="rooter">
                      {t(userLanguage, 'viewoption:showRootText')}
                    </label>
                    <input
                      type="checkbox"
                      id="rooter"
                      checked={viewPrefs.rooter ?? false}
                      aria-controls="rooter-first rooter-side"
                    />
                  </li>
                  <li role="menuitem">
                    <label for="rooter-first">
                      ‚Ü≥ {t(userLanguage, 'viewoption:rootFirst')}
                    </label>
                    <input
                      type="checkbox"
                      id="rooter-first"
                      checked={viewPrefs['rooter-first'] ?? false}
                    />
                  </li>
                  <li role="menuitem">
                    <label for="rooter-side">
                      ‚Ü≥ {t(userLanguage, 'viewoption:sideBySide')}
                    </label>
                    <input
                      type="checkbox"
                      id="rooter-side"
                      checked={viewPrefs['rooter-side'] ?? false}
                    />
                  </li>
                  <li role="menuitem">
                    <label for="rooter-look-up">
                      ‚Ü≥ {t(userLanguage, 'viewoption:wordLookup')}
                    </label>
                    <input
                      type="checkbox"
                      id="rooter-look-up"
                      checked={viewPrefs['rooter-look-up'] ?? false}
                      data-from={rootLang}
                      data-to={lookupTargetLang}
                    />
                  </li>
                </>
              )
            }
            {
              isSegmented && isRootText && availableLangs && (
                <li role="menuitem">
                  <label for="rooter-look-up">
                    {t(userLanguage, 'viewoption:wordLookup')}
                  </label>
                  <input
                    type="checkbox"
                    id="rooter-look-up"
                    checked={viewPrefs['rooter-look-up'] ?? false}
                    data-from={rootLang}
                    data-to={lookupTargetLang}
                  />
                </li>
              )
            }
            {
              (isSegmented ||
                suttasData.translation.text.includes("class='ref")) && (
                <li role="menuitem">
                  <label for="segmenter">
                    {t(userLanguage, 'viewoption:showSegments')}
                  </label>
                  <input
                    type="checkbox"
                    id="segmenter"
                    checked={viewPrefs.segmenter ?? false}
                  />
                </li>
              )
            }
            <li role="menuitem">
              <label for="positioner"
                >{t(userLanguage, 'viewoption:pinMenu')}</label
              >
              <input
                type="checkbox"
                id="positioner"
                checked={viewPrefs.positioner ?? true}
              />
            </li>
          </ul>
        </li>
        <li>
          <button
            popovertarget="parallels"
            aria-label={t(userLanguage, 'viewoption:showParallelTexts')}
          >
            {
              toSentenceCase(
                t(userLanguage, 'interface:showParallelsButtonText')
              )
            }
          </button>
        </li>
        <li>
          <button
            aria-haspopup="menu"
            aria-expanded="false"
            aria-controls="listen-menu"
            aria-label={t(userLanguage, 'viewoption:ttsSettings')}
            id="listen-menu-button"
          >
            {t(userLanguage, 'viewoption:listen')}
          </button>
          <ul
            class="dropdown"
            role="menu"
            aria-labelledby="listen-menu-button"
            id="listen-menu"
            data-label-play={t(userLanguage, 'viewoption:play')}
            data-label-pause={t(userLanguage, 'viewoption:pause')}
            data-label-default={t(userLanguage, 'viewoption:voiceDefault')}
            data-text-lang={language}
          >
            <li>
              <noscript>
                {t(userLanguage, 'viewoption:ttsNoscript')}
              </noscript>
            </li>
            <li role="menuitem" class="tts-controls">
              <button id="prev" type="button">
                <span>‚èÆÔ∏è</span><span>{t(userLanguage, 'viewoption:prev')}</span>
              </button>
              <button id="playpause" type="button">
                <span>‚ñ∂Ô∏è</span><span>{t(userLanguage, 'viewoption:play')}</span>
              </button>
              <button id="stop" type="button">
                <span>‚èπÔ∏è</span><span>{t(userLanguage, 'viewoption:stop')}</span>
              </button>
              <button id="next" type="button">
                <span>‚è≠Ô∏è</span><span>{t(userLanguage, 'viewoption:next')}</span>
              </button>
            </li>
            <li role="menuitem">
              <label for="voice-select"
                >{t(userLanguage, 'viewoption:voiceLabel')}</label
              >
              <select id="voice-select"></select>
            </li>
            <li role="menuitem">
              <label for="rate">{t(userLanguage, 'viewoption:rate')}</label>
              <input
                type="range"
                min="0.5"
                max="2"
                value={viewPrefs.rate ?? '1'}
                step="0.1"
                id="rate"
              />
              <div id="rate-value">1.0</div>
            </li>
            <li role="menuitem">
              <label for="pitch">{t(userLanguage, 'viewoption:pitch')}</label>
              <input
                type="range"
                min="0"
                max="2"
                value={viewPrefs.pitch ?? '1'}
                step="0.1"
                id="pitch"
              />
              <div id="pitch-value">1.0</div>
            </li>
            <li role="menuitem">
              <label for="auto-scroll"
                >{t(userLanguage, 'viewoption:autoScroll')}</label
              >
              <input
                type="checkbox"
                id="auto-scroll"
                checked={viewPrefs['auto-scroll'] ?? false}
              />
            </li>
          </ul>
        </li>
      </ul>
    </fieldset>
  </aside>
  <main>
    <Fragment set:html={articleHTML} />
    <Fragment set:html={commentsHtml} />

    {
      !!publicationData && !publicationData.error && (
        <PublicationInfo entry={publicationData} />
      )
    }

    <article id="parallels" popover>
      <TextMetaContent
        data={suttaplexData[0]}
        userLanguage={userLanguage}
        parallelsOpen
        isIndividualRangeSutta={isRangeSutta}
        inRangeSuttaId={acronym}
      />
    </article>
    {
      availableLangs && (
        <article popover id="definition" aria-label="Word definition" />
      )
    }
  </main>
  <nav aria-label={t(userLanguage, 'interface:articlePagination')}>
    <div>
      {
        suttasData.translation?.previous?.uid ? (
          <>
            <span>{t(userLanguage, 'interface:previous')}</span>
            <a
              href={`/${suttasData.translation.previous.uid}/${suttasData.translation.previous.lang}/${suttasData.translation.previous.author_uid}`}
              rel="prev"
            >
              {suttasData.translation.previous?.name}
            </a>
          </>
        ) : (
          rangePrev && (
            <>
              <span>{t(userLanguage, 'interface:previous')}</span>
              <a href={`/${rangePrev}/${language}/${authorUid}`} rel="prev">
                {uidToAcronym(rangePrev)}
              </a>
            </>
          )
        )
      }
    </div>
    <div>
      {
        suttasData.translation?.next?.uid ? (
          <>
            <span>{t(userLanguage, 'interface:next')}</span>
            <a
              href={`/${suttasData.translation.next.uid}/${suttasData.translation.next.lang}/${suttasData.translation.next.author_uid}`}
              rel="next"
            >
              {suttasData.translation.next?.name}
            </a>
          </>
        ) : (
          rangeNext && (
            <>
              <span>{t(userLanguage, 'interface:next')}</span>
              <a href={`/${rangeNext}/${language}/${authorUid}`} rel="next">
                {uidToAcronym(rangeNext)}
              </a>
            </>
          )
        )
      }
    </div>
  </nav>
</Layout>

<script>
  /**
   * User Preferences Handler
   *
   * Persists all UI preferences to cookies (view and "listen" settings).
   * Cookies read server-side to prevent layout shift, which also
   * eliminates localStorage operations for that perf.
   *
   * @requires document.cookie
   */
  'use strict'

  const IDS = [
    'commenter',
    'commenter-inline',
    'commenter-side',
    'rooter',
    'rooter-first',
    'rooter-look-up',
    'rooter-side',
    'segmenter',
    'positioner',
    'voice-select',
    'rate',
    'pitch',
    'auto-scroll',
  ]

  const COOKIE_NAME = 'viewPrefs'
  const COOKIE_MAX_AGE = 60 * 60 * 24 * 365 * 2 // 2 years

  function getCookiePrefs() {
    try {
      const match = document.cookie.match(
        new RegExp('(^| )' + COOKIE_NAME + '=([^;]+)')
      )
      if (match) {
        return JSON.parse(decodeURIComponent(match[2]))
      }
    } catch (e) {
      console.error('Failed to parse cookie prefs:', e)
    }
    return {}
  }

  function saveToCookie(prefs) {
    try {
      const value = encodeURIComponent(JSON.stringify(prefs))
      // SameSite=Lax allows server to read cookie on navigation from external links
      // (e.g., Google, bookmarks) while still preventing CSRF. Strict would block
      // the cookie on external navigation, breaking this more performant implementation.
      document.cookie = `${COOKIE_NAME}=${value};path=/;max-age=${COOKIE_MAX_AGE};SameSite=Lax`
    } catch (e) {
      console.error('Failed to save cookie prefs:', e)
    }
  }

  /**
   * Wait for the voice-select element to be populated with options.
   * These can load asynchronously from SpeechSynthesis API,
   * so may not be immediately available.
   * Polls every 50ms until options are available or 5 seconds elapse.
   *
   * @returns {Promise<void>} Resolves when options are populated or element doesn't exist
   */
  function waitForVoiceSelect() {
    return new Promise(resolve => {
      const voiceSelect = document.getElementById('voice-select')
      if (!voiceSelect) {
        resolve()
        return
      }

      if (voiceSelect.options.length > 1) {
        resolve()
        return
      }

      let elapsed = 0
      const interval = setInterval(() => {
        elapsed += 50
        if (voiceSelect.options.length > 1) {
          clearInterval(interval)
          resolve()
        } else if (elapsed >= 5000) {
          clearInterval(interval)
          console.warn('Timeout waiting for voice-select options')
          resolve()
        }
      }, 50)
    })
  }

  /**
   * Load voice-select preference once options are available
   */
  function loadVoiceSelect() {
    const el = document.getElementById('voice-select')
    if (!el) return

    const prefs = getCookiePrefs()
    if (!('voice-select' in prefs)) return

    const wanted = prefs['voice-select']
    const opt = [...el.options].find(o => o.dataset.name === wanted)
    if (opt) el.value = opt.value
  }

  /**
   * Save current state of elements found on this page.
   */
  function save() {
    const prefs = getCookiePrefs()

    IDS.forEach(id => {
      const el = document.getElementById(id)
      if (!el) return

      if (el instanceof HTMLInputElement && el.type === 'checkbox') {
        prefs[id] = el.checked
        return
      }

      if (el instanceof HTMLSelectElement) {
        const opt = el.options[el.selectedIndex]
        if (opt?.dataset.name) prefs[id] = opt.dataset.name
        return
      }

      // inputs with value
      if ('value' in el) {
        prefs[id] = el.value
      }
    })

    saveToCookie(prefs)
  }

  /**
   * Set up listeners for all elements present on the current page.
   */
  function init() {
    IDS.forEach(id => {
      const el = document.getElementById(id)
      if (!el) return
      const eventType =
        el instanceof HTMLInputElement && el.type === 'range'
          ? 'input'
          : 'change'
      el.addEventListener(eventType, save)
    })
  }

  init()

  // Dispatch change events on page load so other scripts can initialise correctly (word lookup, TTS)
  IDS.forEach(id => {
    const el = document.getElementById(id)
    if (
      el instanceof HTMLInputElement &&
      el.type === 'checkbox' &&
      el.checked
    ) {
      el.dispatchEvent(new Event('change'))
    }
  })

  waitForVoiceSelect().then(loadVoiceSelect)
</script>

<script>
  /**
   * Word Look-Up Handler
   *
   * Fetches dictionary definitions from the API when the look-up toggle is enabled.
   * Displays definitions in a popover with prev/next navigation between words.
   * Falls back to /define/{word} links when JS is unavailable.
   */
  type LookupEntry = {
    d: string | string[]
    g?: string
    x?: string | string[]
    p?: string
  }
  type PaliMatch = { base: string; entry?: LookupEntry; meaning?: string }

  let data: Record<string, LookupEntry | PaliMatch[]> | null = null
  let words: HTMLAnchorElement[] = []
  let current = -1
  const lookupToggle = document.getElementById(
    'rooter-look-up'
  ) as HTMLInputElement | null
  const rooter = document.getElementById('rooter') as HTMLInputElement | null
  const isLzh = lookupToggle?.dataset.from === 'lzh'
  const popover = document.getElementById('definition') as HTMLElement | null

  lookupToggle?.addEventListener('change', async () => {
    // disabled is used as loading state - prevent concurrent fetches
    if (!lookupToggle.checked || data || lookupToggle.disabled) return
    // Don't fetch if rooter checkbox exists but is unchecked (root text hidden)
    if (rooter && !rooter.checked) return

    lookupToggle.disabled = true

    try {
      const unique = new Set<string>()
      document.querySelectorAll<HTMLAnchorElement>('a.look-up').forEach(el => {
        unique.add(decodeURIComponent(el.pathname.split('/').pop()!))
      })

      const res = await fetch('/api/lookup', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          words: [...unique],
          from: lookupToggle.dataset.from,
          to: lookupToggle.dataset.to,
        }),
      })

      if (!res.ok) throw new Error()

      data = await res.json()
      words = [...document.querySelectorAll<HTMLAnchorElement>('a.look-up')]

      for (const [i, el] of words.entries()) {
        el.addEventListener('click', e => {
          e.preventDefault()
          words.forEach(w => w.classList.remove('active'))
          current = i
          show(decodeURIComponent(el.pathname.split('/').pop()!))
        })
      }
    } catch {
      lookupToggle.checked = false
    } finally {
      lookupToggle.disabled = false
    }
  })

  // When rooter is checked and lookup is already enabled, trigger the fetch
  rooter?.addEventListener('change', () => {
    // disabled is used as loading state - don't dispatch if fetch is in progress
    if (
      rooter.checked &&
      lookupToggle?.checked &&
      !data &&
      !lookupToggle.disabled
    ) {
      lookupToggle.dispatchEvent(new Event('change'))
    }
  })

  function getWord(el: HTMLAnchorElement): string {
    return decodeURIComponent(el.pathname.split('/').pop()!)
  }

  function show(word: string) {
    if (!data || !popover) return

    let items: string[]

    if (isLzh && current >= 0) {
      // Walk 3 chars backward/forward, stop at punctuation (text nodes) or segment boundary
      let start = current
      let end = current
      const seg = words[current].closest('.segment')
      for (let i = current - 1; i >= Math.max(0, current - 3); i--) {
        if (words[i].closest('.segment') !== seg) break
        if (words[i].nextSibling !== words[i + 1]) break
        start = i
      }
      for (let i = current + 1; i < Math.min(words.length, current + 4); i++) {
        if (words[i].closest('.segment') !== seg) break
        if (words[i].previousSibling !== words[i - 1]) break
        end = i
      }
      // Highlight group
      for (let i = start; i <= end; i++) words[i].classList.add('active')
      // Build context and find all substring matches
      const context = words
        .slice(start, end + 1)
        .map(getWord)
        .join('')
      const entries: Array<{ term: string; entry: LookupEntry }> = []
      for (let i = 0; i < context.length; i++) {
        for (let len = 1; len <= context.length - i; len++) {
          const substr = context.substring(i, i + len)
          if (data[substr])
            entries.push({ term: substr, entry: data[substr] as LookupEntry })
        }
      }
      entries.sort((a, b) => b.term.length - a.term.length)
      items = entries.map(e => {
        const defs = Array.isArray(e.entry.d) ? e.entry.d.join('; ') : e.entry.d
        return `<b>${e.term}</b>${e.entry.p ? ` (${e.entry.p})` : ''} ${defs} <a href="/define/${e.term}">üìñ</a>`
      })
    } else {
      // Pali: each word maps to an array of decomposed matches
      const matches = (data[word] as PaliMatch[]) ?? [
        { base: word, meaning: '?' },
      ]
      // When a single match has the same base as the clicked word,
      // skip the nested heading since the top-level <dfn> already shows it
      const skipDt = matches.length === 1 && matches[0].base === word
      items = []
      for (const match of matches) {
        let dd = ''
        if (match.entry) {
          const entry = match.entry
          const defs = Array.isArray(entry.d) ? entry.d : [entry.d]
          if (entry.g) dd += `<span class="grammar">${entry.g}</span>`
          dd += `<ol class="definition">${defs.map(d => `<li>${d}</li>`).join('')}</ol>`
          if (entry.x) {
            const xrs = Array.isArray(entry.x) ? entry.x : [entry.x]
            dd += `<ul class="xr">${xrs.map((t: string) => `<li><a href="/define/${t}">See: ${t}</a></li>`).join('')}</ul>`
          }
        } else {
          dd = match.meaning ?? '<ol><li>?</li></ol>'
        }
        if (skipDt) {
          items.push(`<dl><dd>${dd}</dd></dl>`)
        } else {
          items.push(
            `<dl><dt><dfn>${match.base} <a href="/define/${match.base}">üìñ</a></dfn></dt><dd>${dd}</dd></dl>`
          )
        }
      }
      words[current]?.classList.add('active')
    }

    if (items.length === 0) return

    const content = isLzh
      ? `<dfn>${word}</dfn><ol>${items.map(d => `<li>${d}</li>`).join('')}</ol>`
      : `<dfn>${word}</dfn>${items.join('')}`

    popover.innerHTML =
      `<section>${content}</section>` +
      `<nav aria-label="Word definition navigation">` +
      `<button id="def-prev" aria-label="Previous word"${current <= 0 ? ' disabled' : ''}>\u2190</button>` +
      `<a href="/define/${word}" aria-label="Full definition for ${word}">üìñ</a>` +
      `<button id="def-next" aria-label="Next word"${current >= words.length - 1 ? ' disabled' : ''}>\u2192</button></nav>`
    popover.showPopover()
    // Scroll clicked word into view if the popover will cover it
    const rect = words[current]?.getBoundingClientRect()
    // Lookup popover is set to 30vh
    if (rect && rect.bottom > window.innerHeight * 0.7) {
      words[current]?.scrollIntoView({ block: 'center', behavior: 'smooth' })
    }
  }

  popover?.addEventListener('click', e => {
    const btn = (e.target as HTMLElement).closest('#def-prev, #def-next')
    if (!btn) return
    const next = current + (btn.id === 'def-prev' ? -1 : 1)
    if (next < 0 || next >= words.length) return
    words.forEach(w => w.classList.remove('active'))
    current = next
    show(getWord(words[current]))
  })

  popover?.addEventListener('toggle', (e: Event) => {
    if ((e as ToggleEvent).newState === 'closed') {
      words.forEach(w => w.classList.remove('active'))
    }
  })
</script>

<script>
  /**
   * Text-to-Speech Player
   *
   * Provides speech synthesis controls for reading article content aloud.
   * Features include play/pause/stop controls, navigation between segments,
   * voice selection, pitch/rate adjustment, auto-scrolling, and click-to-jump.
   *
   * Handles both segmented text (via span.text elements) and non-segmented
   * content by manually extracting visible text-containing elements.
   *
   * @requires SpeechSynthesis API
   *
   * @example
   * // Access debug state
   * window._scx_listen.getState()
   *
   * @example
   * // Cancel all playback
   * window._scx_listen.cancel()
   */

  'use strict'

  // Configurable constants
  const TIMEOUT_MS = 60
  const CLASS_HIGHLIGHT = 'tts-highlight'
  const CLASS_CLICKABLE = 'tts-clickable'
  const ICON_PLAY = '‚ñ∂Ô∏è'
  const ICON_PAUSE = '‚è∏Ô∏è'
  const ICON_RESUME = '‚ñ∂Ô∏è'

  const synth = window.speechSynthesis

  // state
  let voices = []
  let visibleTextSpans = []
  let visibleTextContent = []
  let currentIndex = 0
  let isCancelled = false
  let isPlaying = false // denotes an active session (playing or paused)
  let currentUtterance = null
  let sessionId = 0

  // DOM
  const menuButton = document.getElementById('listen-menu-button')
  const rootMenuEl = document.getElementById('listen-menu')
  const LABEL_PLAY = rootMenuEl.dataset.labelPlay
  const LABEL_PAUSE = rootMenuEl.dataset.labelPause
  const LABEL_RESUME = LABEL_PLAY
  const LABEL_DEFAULT = rootMenuEl.dataset.labelDefault
  const voiceSelect = document.getElementById('voice-select')
  const pitch = document.getElementById('pitch')
  const pitchValue = document.getElementById('pitch-value')
  const rate = document.getElementById('rate')
  const rateValue = document.getElementById('rate-value')

  const prevBtn = document.getElementById('prev')
  const playPauseBtn = document.getElementById('playpause')
  const playPauseBtnIcon = playPauseBtn.getElementsByTagName('span')[0]
  const playPauseBtnLabel = playPauseBtn.getElementsByTagName('span')[1]
  const nextBtn = document.getElementById('next')
  const stopBtn = document.getElementById('stop')
  const autoScrollToggle = document.getElementById('auto-scroll')

  const rootFirst = document.getElementById('rooter-first')

  // basic sanity
  if (!rootMenuEl) {
    console.warn('listen.js: required controls missing; aborting init.')
  } else {
    // enable all the controls (they are disabled by default to show fallback text if user has JS turned off)
    rootMenuEl.style.maxWidth = '100vw'
    rootMenuEl.querySelectorAll('li[role="menuitem"]').forEach(el => {
      el.style.display = 'flex'
    })

    function computeVisibleText() {
      // for segmented texts
      visibleTextSpans = Array.from(
        document.querySelectorAll(
          'main > article span.text, main > section span.text'
        )
      ).filter(s => s.offsetParent !== null && s.textContent)

      visibleTextContent = visibleTextSpans?.map(s =>
        s.textContent.replace(/\n/g, '')
      )

      // If rooter-first is checked, reorder spans within each segment to match CSS grid display order
      if (rootFirst && rootFirst.checked && visibleTextSpans.length > 0) {
        const segments = new Map()

        // Group spans by their parent segment
        visibleTextSpans.forEach((span, index) => {
          const segment = span.closest('.segment')
          if (segment) {
            if (!segments.has(segment)) {
              segments.set(segment, [])
            }
            segments.get(segment).push({ span, index })
          }
        })

        // For each segment, if it has both translation and root text, swap their order
        segments.forEach((items, segment) => {
          if (items.length >= 2) {
            const translationItem = items.find(item =>
              item.span.closest('.translation')
            )
            const rootItem = items.find(item => item.span.closest('.root'))

            // If both exist, swap them in the arrays
            if (translationItem && rootItem) {
              const tempSpan = visibleTextSpans[translationItem.index]
              const tempContent = visibleTextContent[translationItem.index]

              visibleTextSpans[translationItem.index] =
                visibleTextSpans[rootItem.index]
              visibleTextContent[translationItem.index] =
                visibleTextContent[rootItem.index]

              visibleTextSpans[rootItem.index] = tempSpan
              visibleTextContent[rootItem.index] = tempContent
            }
          }
        })
      }

      // fallback for messy DOM in non segmented texts
      if (!visibleTextSpans.length || !visibleTextContent.length) {
        const textContainingElements = [
          'div',
          'span',
          'p',
          'blockquote',
          'pre',
          'address',
          'h1',
          'h2',
          'h3',
          'h4',
          'h5',
          'h6',
          'ul',
          'ol',
          'li',
          'dl',
          'dt',
          'dd',
          'a',
          'abbr',
          'b',
          'strong',
          'i',
          'em',
          'mark',
          'small',
          'del',
          'ins',
          'sub',
          'sup',
          'code',
          'kbd',
          'samp',
          'var',
          'cite',
          'dfn',
          'q',
          's',
          'u',
          'time',
          'data',
          'bdi',
          'bdo',
          'ruby',
          'rt',
          'rp',
          'table',
          'caption',
          'thead',
          'tbody',
          'tfoot',
          'tr',
          'th',
          'td',
          'colgroup',
          'col',
          'form',
          'label',
          'button',
        ]
        const selector = textContainingElements
          .map(e => `main > article ${e}`)
          .join(', ')
        const allVisibleElements = Array.from(
          document.querySelectorAll(selector)
        ).filter(s => s.offsetParent !== null && s.textContent)

        function getUniqueSelector(node, root) {
          const path = []
          let current = node
          while (current && current !== root) {
            let index = 0
            let sibling = current
            while ((sibling = sibling.previousElementSibling)) {
              if (sibling.tagName === current.tagName) index++
            }
            path.unshift(
              `${current.tagName.toLowerCase()}:nth-of-type(${index + 1})`
            )
            current = current.parentElement
          }
          return path.join(' > ')
        }

        visibleTextSpans = allVisibleElements.filter(el => {
          // avoid duplicates
          return !allVisibleElements.some(
            other => other !== el && other.contains(el)
          )
        })

        visibleTextContent = visibleTextSpans.map(el => {
          const clone = el.cloneNode(true)

          // remove all .ref elements from the clone
          const refElements = clone.querySelectorAll('.ref')
          refElements.forEach(ref => ref.remove())

          // Find all descendants in the clone and check if corresponding original is hidden
          const allDescendants = clone.querySelectorAll('*')
          Array.from(allDescendants).forEach(cloneDesc => {
            const selector = getUniqueSelector(cloneDesc, clone)
            const originalDesc = el.querySelector(selector)
            if (originalDesc && originalDesc.offsetParent === null) {
              cloneDesc.remove()
            }
          })

          return clone.textContent.replace(/\n/g, '')
        })
      }
    }

    function updateClickableSpans() {
      if (!visibleTextSpans || !visibleTextSpans.length) return
      if (isPlaying) {
        visibleTextSpans.forEach(s => s.classList.add(CLASS_CLICKABLE))
      } else {
        visibleTextSpans.forEach(s => s.classList.remove(CLASS_CLICKABLE))
      }
    }

    function setNavControlsEnabled(enabled) {
      if (prevBtn) prevBtn.disabled = !enabled
      if (nextBtn) nextBtn.disabled = !enabled
      if (stopBtn) stopBtn.disabled = !enabled
    }

    function ensureVisible(index) {
      if (!autoScrollToggle) return
      if (!autoScrollToggle.checked) return
      const el = visibleTextSpans[index]
      if (!el) return
      try {
        el.scrollIntoView({
          behavior: 'smooth',
          block: 'center',
          inline: 'nearest',
        })
      } catch (e) {}
    }

    function updatePlayPauseLabel() {
      if (synth.paused) {
        playPauseBtnLabel.textContent = LABEL_RESUME
        playPauseBtnIcon.textContent = ICON_RESUME
        return
      }
      if (synth.speaking && !synth.paused) {
        playPauseBtnLabel.textContent = LABEL_PAUSE
        playPauseBtnIcon.textContent = ICON_PAUSE
        return
      }
      playPauseBtnLabel.textContent = LABEL_PLAY
      playPauseBtnIcon.textContent = ICON_PLAY
    }

    function populateVoiceList() {
      voices =
        typeof synth.getVoices === 'function' ? synth.getVoices().slice() : []

      // Group voices by language
      const byLang = new Map()
      for (const v of voices) {
        const lang = v.lang || 'unknown'
        if (!byLang.has(lang)) byLang.set(lang, [])
        byLang.get(lang).push(v)
      }

      // Sort languages alphabetically
      const langs = Array.from(byLang.keys()).sort((a, b) => {
        const aa = (a || '').toUpperCase()
        const bb = (b || '').toUpperCase()
        if (aa < bb) return -1
        if (aa === bb) return 0
        return 1
      })

      // Sort voices within each language by name
      for (const [, list] of byLang) {
        list.sort((a, b) => {
          const an = (a.name || '').toUpperCase()
          const bn = (b.name || '').toUpperCase()
          if (an < bn) return -1
          if (an === bn) return 0
          return 1
        })
      }

      // Determine preferred voice to select: text language first, then default voice, then browser lang
      const defaultVoice = voices.find(v => v.default)
      const textLang = rootMenuEl?.dataset?.textLang ?? ''
      const browserLang = (
        navigator.language ||
        navigator.userLanguage ||
        ''
      ).toString()
      const primaryBrowserLang = browserLang.split('-')[0]
      let suitableVoiceName = null

      // First try to match text language (prefer default voice if multiple matches)
      if (textLang) {
        const textLangVoices = voices.filter(
          v => v.lang === textLang || (v.lang && v.lang.startsWith(textLang))
        )
        if (textLangVoices.length > 0) {
          const defaultInLang = textLangVoices.find(v => v.default)
          suitableVoiceName = defaultInLang
            ? defaultInLang.name
            : textLangVoices[0].name
        }
      }

      // Fall back to default voice
      if (!suitableVoiceName && defaultVoice) {
        suitableVoiceName = defaultVoice.name
      }

      // Fall back to browser language
      if (!suitableVoiceName && browserLang) {
        // find first voice matching full lang, then primary subtag
        let found = voices.find(v => v.lang === browserLang)
        if (!found)
          found = voices.find(
            v => v.lang && v.lang.startsWith(primaryBrowserLang)
          )
        if (found) suitableVoiceName = found.name
      }

      // Build select with optgroups per language
      voiceSelect.innerHTML = ''
      for (const lang of langs) {
        const group = document.createElement('optgroup')
        group.label = lang
        const list = byLang.get(lang) || []
        for (const v of list) {
          const opt = document.createElement('option')
          opt.textContent = `${v.name}${v.default ? ` -- ${LABEL_DEFAULT}` : ''}`
          opt.setAttribute('data-name', v.name)
          opt.setAttribute('data-lang', v.lang)
          group.appendChild(opt)
        }
        voiceSelect.appendChild(group)
      }

      // Select initial option if present, otherwise preserve previous selection or pick first
      let selIndex = 0
      if (suitableVoiceName) {
        for (let i = 0; i < voiceSelect.options.length; i++) {
          if (
            voiceSelect.options[i].getAttribute('data-name') ===
            suitableVoiceName
          ) {
            selIndex = i
            break
          }
        }
      } else {
        selIndex =
          voiceSelect.selectedIndex >= 0 ? voiceSelect.selectedIndex : 0
      }
      voiceSelect.selectedIndex = Math.min(
        selIndex,
        Math.max(0, voiceSelect.options.length - 1)
      )
    }
    populateVoiceList()
    if (typeof synth !== 'undefined' && synth.onvoiceschanged !== undefined) {
      synth.onvoiceschanged = populateVoiceList
    }

    // Speak chain with session protection
    function speakNext() {
      const mySession = sessionId
      if (currentIndex >= visibleTextContent.length) {
        finishPlayback()
        return
      }
      const text = visibleTextContent[currentIndex]
      if (!text || isCancelled) {
        finishPlayback()
        return
      }

      const utter = new SpeechSynthesisUtterance(text)
      utter._session = mySession
      currentUtterance = utter

      utter.onstart = () => {
        if (utter._session !== sessionId) return
        visibleTextSpans[currentIndex]?.classList.add(CLASS_HIGHLIGHT)
        ensureVisible(currentIndex)
        // immediate label update when speech starts
        updatePlayPauseLabel()
      }

      utter.onend = () => {
        if (utter._session !== sessionId) return
        visibleTextSpans[currentIndex]?.classList.remove(CLASS_HIGHLIGHT)
        currentUtterance = null
        if (isCancelled) {
          finishPlayback()
          return
        }
        currentIndex += 1
        // If paused between utterances, don't auto-advance
        if (synth.paused) {
          updatePlayPauseLabel()
          return
        }
        speakNext()
      }

      utter.onerror = ev => {
        if (utter._session !== sessionId) return
        console.error('SpeechSynthesisUtterance error', ev)
        visibleTextSpans[currentIndex]?.classList.remove(CLASS_HIGHLIGHT)
        currentUtterance = null
        currentIndex += 1
        if (!isCancelled) speakNext()
      }

      // set voice
      const selected =
        voiceSelect.selectedOptions && voiceSelect.selectedOptions[0]
          ? voiceSelect.selectedOptions[0].getAttribute('data-name')
          : null
      if (selected) {
        const v = voices.find(x => x.name === selected)
        if (v) utter.voice = v
      }
      utter.pitch = pitch ? Number(pitch.value) : 1
      utter.rate = rate ? Number(rate.value) : 1

      try {
        synth.speak(utter)
      } catch (err) {
        console.error('synth.speak threw', err)
      }
    }

    // Controls
    function startSessionFrom(index = 0) {
      computeVisibleText()
      if (!visibleTextContent.length || !visibleTextSpans.length) return
      sessionId += 1
      isCancelled = false
      isPlaying = true
      currentIndex = Math.max(0, Math.min(index, visibleTextContent.length - 1))
      playPauseBtnLabel.textContent = LABEL_PAUSE
      playPauseBtnIcon.textContent = ICON_PAUSE
      setNavControlsEnabled(true)
      updateClickableSpans()
      speakNext()
    }

    function pauseSession() {
      if (synth.speaking && !synth.paused) {
        try {
          synth.pause()
          // set label immediately for UI responsiveness
          playPauseBtnLabel.textContent = LABEL_RESUME
          playPauseBtnIcon.textContent = ICON_RESUME
          return
        } catch (err) {
          console.error('pause failed', err)
        }
      }
      updateClickableSpans()
    }

    function resumeSession() {
      if (synth.paused) {
        try {
          synth.resume()
          // set label immediately for UI responsiveness
          playPauseBtnLabel.textContent = LABEL_PAUSE
          playPauseBtnIcon.textContent = ICON_PAUSE
        } catch (err) {
          console.error('resume failed', err)
        }
      } else if (
        !synth.speaking &&
        !isCancelled &&
        currentIndex < visibleTextContent.length
      ) {
        // nothing is speaking but we have work to do
        speakNext()
        playPauseBtnLabel.textContent = LABEL_PAUSE
        playPauseBtnIcon.textContent = ICON_PAUSE
      }
      updateClickableSpans()
    }

    function prevSpan() {
      computeVisibleText()
      if (!visibleTextContent.length) return
      const newIndex = Math.max(0, currentIndex - 1)
      sessionId += 1
      isCancelled = true
      try {
        synth.cancel()
      } catch (e) {}
      visibleTextSpans.forEach(s => s.classList.remove(CLASS_HIGHLIGHT))
      setTimeout(() => {
        if (sessionId == null) return
        isCancelled = false
        currentIndex = newIndex
        if (isPlaying && !synth.paused) {
          speakNext()
        } else {
          visibleTextSpans[currentIndex]?.classList.add(CLASS_HIGHLIGHT)
          ensureVisible(currentIndex)
          updatePlayPauseLabel()
        }
      }, TIMEOUT_MS)
    }

    function nextSpan() {
      computeVisibleText()
      if (!visibleTextContent.length) return
      const newIndex = Math.min(visibleTextContent.length - 1, currentIndex + 1)
      sessionId += 1
      isCancelled = true
      try {
        synth.cancel()
      } catch (e) {}
      visibleTextSpans.forEach(s => s.classList.remove(CLASS_HIGHLIGHT))
      setTimeout(() => {
        if (sessionId == null) return
        isCancelled = false
        currentIndex = newIndex
        if (isPlaying && !synth.paused) {
          speakNext()
        } else {
          visibleTextSpans[currentIndex]?.classList.add(CLASS_HIGHLIGHT)
          ensureVisible(currentIndex)
          updatePlayPauseLabel()
        }
      }, TIMEOUT_MS)
    }

    function finishPlayback() {
      sessionId += 1
      visibleTextSpans.forEach(s => {
        s.classList.remove(CLASS_HIGHLIGHT)
        s.classList.remove(CLASS_CLICKABLE)
      })
      isPlaying = false
      currentUtterance = null
      currentIndex = 0
      playPauseBtnLabel.textContent = LABEL_PLAY
      playPauseBtnIcon.textContent = ICON_PLAY
      setNavControlsEnabled(false)
      updateClickableSpans()
    }

    function stopSession() {
      // Cancel any ongoing speech and reset UI/state.
      sessionId += 1
      isCancelled = true
      try {
        synth.cancel()
      } catch (e) {}
      visibleTextSpans.forEach(s => {
        s.classList.remove(CLASS_HIGHLIGHT)
      })
      currentUtterance = null
      isPlaying = false
      currentIndex = 0
      playPauseBtnLabel.textContent = LABEL_PLAY
      playPauseBtnIcon.textContent = ICON_PLAY
      setNavControlsEnabled(false)
      updateClickableSpans()
    }

    // single button behavior
    function togglePlayPause() {
      if (synth.paused) {
        // if paused, resume immediately and update label
        resumeSession()
        return
      }
      if (isPlaying && synth.speaking && !synth.paused) {
        // pause immediately and update label
        pauseSession()
        return
      }
      // not started -> start session from currentIndex (or 0)
      if (!isPlaying) {
        startSessionFrom(currentIndex || 0)
        return
      }
      // if idle but there's remaining content, continue
      if (
        !synth.speaking &&
        !isCancelled &&
        currentIndex < visibleTextContent.length
      ) {
        isPlaying = true
        playPauseBtnLabel.textContent = LABEL_PAUSE
        playPauseBtnIcon.textContent = ICON_PAUSE
        updateClickableSpans()
        speakNext()
      }
    }

    // wire listeners
    if (prevBtn) prevBtn.addEventListener('click', prevSpan)
    playPauseBtn.addEventListener('click', togglePlayPause)
    if (nextBtn) nextBtn.addEventListener('click', nextSpan)
    if (stopBtn) stopBtn.addEventListener('click', stopSession)

    // allow clicking any visibleTextSpans to jump/start speaking from there
    const articleEl = document.querySelector('main > article, main > section')
    if (articleEl)
      articleEl.addEventListener('click', ev => {
        // Only allow click-to-jump once playback has already started
        if (!isPlaying) return

        // find the nearest element that was clicked
        // for segmented texts this will work
        let clickedElement =
          ev.target && ev.target.closest ? ev.target.closest('span.text') : null

        // for non-segmented texts, check if it's one of the visibleTextSpans
        if (!clickedElement) {
          // ignore reference link clicks
          if (ev.target.closest('.ref')) return

          clickedElement = ev.target
          // Walk up the tree to find if we're inside a visibleTextSpan
          while (clickedElement && !visibleTextSpans.includes(clickedElement)) {
            clickedElement = clickedElement.parentElement
            if (clickedElement === articleEl) {
              clickedElement = null
              break
            }
          }
        }

        if (!clickedElement) return

        computeVisibleText()
        const idx = visibleTextSpans.indexOf(clickedElement)
        if (idx < 0) return

        // cancel current session/utterances and start from clicked index
        sessionId += 1
        isCancelled = true
        try {
          synth.cancel()
        } catch (e) {}
        visibleTextSpans.forEach(s => s.classList.remove(CLASS_HIGHLIGHT))

        setTimeout(() => {
          isCancelled = false
          // reuse existing start logic to initialize state and begin speaking
          startSessionFrom(idx)
        }, TIMEOUT_MS)
      })

    if (pitch) {
      pitchValue.textContent = pitch.valueAsNumber.toFixed(1)
      pitch.addEventListener(
        'change',
        () => (pitchValue.textContent = pitch.valueAsNumber.toFixed(1))
      )
    }
    if (rate) {
      rateValue.textContent = rate.valueAsNumber.toFixed(1)
      rate.addEventListener(
        'change',
        () => (rateValue.textContent = rate.valueAsNumber.toFixed(1))
      )
    }

    // initial nav state
    setNavControlsEnabled(false)

    // debug helper
    window._scx_listen = {
      getState() {
        return {
          isPlaying,
          isCancelled,
          currentIndex,
          sessionId,
          paused: synth.paused,
          speaking: synth.speaking,
        }
      },
      cancel() {
        sessionId += 1
        isCancelled = true
        try {
          synth.cancel()
        } catch (e) {}
      },
    }
  }
</script>
