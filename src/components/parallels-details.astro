---
import '~/assets/details.css'
import { t } from '~/i18n'
import { toSentenceCase } from '~/utils/strings'
const {
  data: entry,
  parallelsOpen,
  userLanguage,
  isIndividualRangeSutta,
  inRangeSuttaId,
} = Astro.props

const parallelsResponse = await fetch(
  `https://suttacentral.net/api/parallels/${entry.uid}`
)
const parallelsData = await parallelsResponse.json()

const rootTrans = entry.translations.find((t: any) => t.is_root)

// Make pretty PTS volpages
function formatVolpages(volpages: string | null): string {
  if (!volpages) return ''
  if (!volpages.includes('PTS')) return volpages

  const parts = volpages.trim().split(', ')
  if (parts.length < 2) return volpages

  const firstParts = parts[0].trim().split(' ')
  const lastParts = parts[parts.length - 1].trim().split(' ')
  const prefix = firstParts[0]
  const firstNum = firstParts[firstParts.length - 1]
  const lastNum = lastParts[lastParts.length - 1]

  return `${prefix} ${firstNum}—${lastNum}`
}

// Helper to get base path from segment key
function getBasePath(segmentKey: string): string {
  let basePath = segmentKey
  if (segmentKey.includes('#')) {
    basePath = segmentKey.split('#')[0]
  }
  return basePath
}

function getHashFragment(key: string): string {
  if (key.includes('#')) {
    return '#' + key.split('#')[1]
  }
  return ''
}

function getParallelTypeTitle(type: string): string {
  switch (type) {
    case 'full':
      return t(userLanguage, 'suttaplex:fullParallel')
    case 'mention':
      return t(userLanguage, 'suttaplex:mention')
    case 'retelling':
      return t(userLanguage, 'suttaplex:retellingParallel')
    case 'resembling': // ¿¿what texts have this??
      return t(userLanguage, 'suttaplex:resemblingParallel')
    default:
      return ''
  }
}

// Filter out metadata entries
const segments = Object.entries(parallelsData).filter(
  ([key]) => !key.startsWith('_scx_')
)

// Filtered to include only relevant parallels for this individual range entry
const filterUid = inRangeSuttaId ?? entry.uid

const filteredSegments =
  !!segments.length &&
  (isIndividualRangeSutta
    ? segments.filter(([k]) => {
        // Direct matches, and start of range
        if (
          k === filterUid ||
          k.startsWith(`${filterUid}-`) ||
          k.startsWith(`${filterUid}#`)
        ) {
          return true
        }

        // Check if uid is at the END of a range
        // So if uid is dhp20, will match dhp*-20, and if uid is an1.197, will match an1.*-197, and both with # links
        const uidPrefix = filterUid.split(/(\d+)/)[0]
        const uidEndNum = filterUid.match(/\d+$/)?.[0]
        if (
          uidEndNum &&
          new RegExp(`^${uidPrefix}(\\d+)(\\.\\d+)?-${uidEndNum}(#.*)?$`).test(
            k
          )
        ) {
          return true
        }

        // Check if uid is WITHIN a range (an1.1 matches an1.1-5, dhp2 matches dhp1-3)
        const kBase = k.split('#')[0]
        const rangeMatch = kBase.match(/^(.+?)(\d+)(?:\.(\d+))?-(\d+)$/)
        if (rangeMatch) {
          const [
            ,
            rangePrefix,
            rangeNumIfDecimalOrStart,
            rangeStartIfDecimal,
            rangeEnd,
          ] = rangeMatch
          const uidMatch = filterUid.match(/^(.+?)(\d+)(?:\.(\d+))?$/)
          if (uidMatch) {
            const [, currentPrefix, currentNum, currentDecimal] = uidMatch
            if (rangePrefix === currentPrefix) {
              if (rangeStartIfDecimal) {
                if (rangeNumIfDecimalOrStart === currentNum) {
                  const start = parseInt(rangeStartIfDecimal)
                  const end = parseInt(rangeEnd)
                  const current = parseInt(currentDecimal)
                  if (current >= start && current <= end) return true
                }
              } else {
                const start = parseInt(rangeNumIfDecimalOrStart)
                const end = parseInt(rangeEnd)
                const current = parseInt(currentNum)
                if (current >= start && current <= end) return true
              }
            }
          }
        }

        return false
      })
    : segments)

const parallelCount =
  isIndividualRangeSutta && filteredSegments
    ? filteredSegments.reduce(
        (sum, [, parallels]) => sum + (parallels as any[]).length,
        0
      )
    : entry.parallel_count
---

<details open={parallelsOpen && parallelCount}>
  <summary>
    {
      toSentenceCase(
        `${t(userLanguage, parallelCount !== 1 ? 'suttaplex:countParallels' : 'suttaplex:countParallel', { count: null })} ${t(userLanguage, 'suttaplex:inAncientTexts')}`
      )
    }
    ({parallelCount})
  </summary>
  <ul>
    {
      !!filteredSegments.length ? (
        filteredSegments.map(([segmentKey, parallels]) => (
          <li>
            {rootTrans ? (
              <a
                href={`/${getBasePath(segmentKey)}/${rootTrans.lang}/${rootTrans.author_uid}${getHashFragment(segmentKey)}`}
              >
                {segmentKey}
              </a>
            ) : (
              <span>{segmentKey}</span>
            )}
            <ul>
              {(parallels as any[]).map(parallel => {
                const prettyVolpages = formatVolpages(parallel.to.volpages)
                const hasTranslations = parallel.to.translations?.length > 0
                const firstTrans = parallel.to.translations?.[0]
                const displayTitle =
                  parallel.to.translated_title?.trim() ||
                  parallel.to.original_title?.trim() ||
                  parallel.to.acronym?.trim()

                return (
                  <li
                    class={`parallel-list-item-${parallel.to.type}`}
                    title={getParallelTypeTitle(parallel.to.type)}
                  >
                    {hasTranslations ? (
                      <a
                        href={`/${parallel.to.uid}/${firstTrans.lang}/${firstTrans.author_uid}${getHashFragment(parallel.to.to)}`}
                        hreflang={firstTrans.lang}
                      >
                        {displayTitle}
                      </a>
                    ) : (
                      <span>{displayTitle}</span>
                    )}

                    {/* Secondary info line */}
                    {parallel.to.translated_title &&
                    parallel.to.original_title ? (
                      <div>
                        {parallel.to.original_title.trim()}
                        {parallel.to.acronym && (
                          <> ∙ {parallel.to.acronym.trim()}</>
                        )}
                        {prettyVolpages && <> ∙ {prettyVolpages.trim()}</>}
                      </div>
                    ) : parallel.to.original_title ? (
                      <div>
                        {parallel.to.acronym && (
                          <>{parallel.to.acronym.trim()}</>
                        )}
                        {prettyVolpages && <> ∙ {prettyVolpages.trim()}</>}
                      </div>
                    ) : parallel.to.acronym && prettyVolpages ? (
                      <div>{prettyVolpages.trim()}</div>
                    ) : null}
                  </li>
                )
              })}
            </ul>
          </li>
        ))
      ) : (
        <li>{t(userLanguage, 'suttaplex:hasNoParallels')}</li>
      )
    }
  </ul>
</details>
